const QuizSet = require("../models/QuizSet");
const User = require('../models/User');
const Category=require('../models/Category')
const { generateQuizOfTheDay }= require('../utills/getQuizOfTheDay');
const {generateQuestions} = require('../utills/generateQuestion'); 
let cachedQuiz = null;
let lastQuizDate = null;

exports.getCategories=async (req,res)=>{
    try{
      
        const category=await Category.find({});
        res.status(200).json({
            categories:category
        })

    }catch(e){
        console.log("SOme error occured while fetchin the quiz categories",e)
        res.status(500).json({ message: "Failed to fetch category" });
    }
}

exports.getQuizSets=async (req,res)=>{ 
  try{
       const randomSets= await QuizSet.find({},{questions:0}).populate('category')
         res.status(200).json({
            quiz:randomSets
        })
  }catch(e){
        console.log("SOme error occured while fetchin the sets",e)
        res.status(500).json({ message: "Failed to fetch category" });
    }
   
}
 
exports.startPredefinedQuiz = async (req, res) => {
  try {
   
    const quizId = req.params.id
  const quizzes = await QuizSet.findById(quizId).populate('questions').populate('category');


    if (quizzes.length === 0) {
      return res.status(404).json({ message: "No quizzes found for this id" });
    }
   res.status(200).json({ questions: quizzes.questions,Id:quizId,category:quizzes.category.title,difficulty:quizzes.difficulty});
  } catch (e) {
    console.log("Error occurred while fetching quizzes:", e);
    res.status(500).json({ message: "Failed to fetch quizzes of this category" });
  }
};




exports.startQuiz = async (req, res) => {
  try {
    const { id: categoryId } = req.params;
    const { difficulty, numberOfQuestions, userId } = req.body;
    const user = await User.findById(userId);
    // 1. Fetch all quiz sets for category
    let allQuizSets = await QuizSet.find({
      category: categoryId,
      difficulty: difficulty,
    });
    // 2. Filter out quiz sets already played by user
    const playedQuizSetIds =
      user.quizzesTaken.map((q) => q.quizId.toString()) || [];
    let availableQuizSet = allQuizSets.find(
      (set) => !playedQuizSetIds.includes(set._id.toString())
    );
    // 3. If no available set, generate new quiz set
    if (!availableQuizSet) {
      console.log(
        "No available quiz sets or already played — generating new set..."
      );

      const generatedQuestions = await generateQuestions(
        categoryId,
        difficulty,
        numberOfQuestions
      );

      const newQuizSet = new QuizSet({
        title: `Auto Generated - ${difficulty} Quiz`,
        description: "This quiz was generated by AI.",
        category: categoryId,
        difficulty: difficulty.charAt(0).toUpperCase() + difficulty.slice(1),
        duration: Math.ceil(numberOfQuestions * 0.5), // e.g., 30 secs/question
        questions: generatedQuestions.map((q) => q._id),
        totalQuestions: generatedQuestions.length,
        createdBy: userId,
      });

      await newQuizSet.save();
      availableQuizSet = newQuizSet;
    }

    // 4. Populate questions
    const populatedQuiz = await QuizSet.findById(availableQuizSet._id).populate(
      "questions"
    );

    // 5. Filter and shuffle
    let selectedQuestions = populatedQuiz.questions
      .filter((q) => q.level === difficulty)
      .sort(() => 0.5 - Math.random())
      .slice(0, numberOfQuestions);

    // If not enough, fill with other levels
    if (selectedQuestions.length < numberOfQuestions) {
      const remaining = numberOfQuestions - selectedQuestions.length;
      const fallbackQuestions = populatedQuiz.questions
        .filter((q) => q.level !== difficulty)
        .sort(() => 0.5 - Math.random())
        .slice(0, remaining);

      selectedQuestions = [...selectedQuestions, ...fallbackQuestions];
    }

    return res.status(200).json({
      quizId: populatedQuiz._id,
      questions: selectedQuestions,
      difficulty,
    });
  } catch (error) {
    console.error("Error starting quiz:", error);
    return res.status(500).json({ message: "Failed to start quiz" });
  }
};
exports.startGuestQuiz = async (req, res) => {
  try {
    const { id: categoryId } = req.params;
    const { difficulty, numberOfQuestions } = req.body;

    // 1. Fetch all quiz sets for category and difficulty
    let allQuizSets = await QuizSet.find({
      category: categoryId,
      difficulty: difficulty,
    });

    // 2. Just pick the first available set (guests don't track history)
    let availableQuizSet = allQuizSets[0];

    // 3. If no set found, generate a new one
    if (!availableQuizSet) {
      console.log("No available sets — generating for guest...");

      const generatedQuestions = await generateQuestions(
        categoryId,
        difficulty,
        numberOfQuestions
      );

      const newQuizSet = new QuizSet({
        title: `Guest - Auto Generated - ${difficulty} Quiz`,
        description: "This quiz was generated for a guest user.",
        category: categoryId,
        difficulty: difficulty.charAt(0).toUpperCase() + difficulty.slice(1),
        duration: Math.ceil(numberOfQuestions * 0.5),
        questions: generatedQuestions.map((q) => q._id),
        totalQuestions: generatedQuestions.length,
        createdBy: undefined, // no user
      });

      await newQuizSet.save();
      availableQuizSet = newQuizSet;
    }

    // 4. Populate and shuffle questions
    const populatedQuiz = await QuizSet.findById(availableQuizSet._id).populate("questions");

    let selectedQuestions = populatedQuiz.questions
      .filter((q) => q.level === difficulty)
      .sort(() => 0.5 - Math.random())
      .slice(0, numberOfQuestions);

    if (selectedQuestions.length < numberOfQuestions) {
      const remaining = numberOfQuestions - selectedQuestions.length;
      const fallbackQuestions = populatedQuiz.questions
        .filter((q) => q.level !== difficulty)
        .sort(() => 0.5 - Math.random())
        .slice(0, remaining);

      selectedQuestions = [...selectedQuestions, ...fallbackQuestions];
    }

    console.log("Guest quiz started successfully.");

    return res.status(200).json({
      quizId: populatedQuiz._id,
      questions: selectedQuestions,
      difficulty,
    });
  } catch (error) {
    console.error("Error starting guest quiz:", error);
    return res.status(500).json({ message: "Failed to start guest quiz" });
  }
};


exports.getMyCreatedQuizzes = async (req, res) => {
  try {
    const userId = req.user._id; 
    const user = await User.findById(userId).populate('quizzesCreated');
    if (!user) {
      return res.status(404).json({ message: 'User not found' });
    }

    return res.status(200).json({ 
      success: true,
      quizzes: user.quizzesCreated 
    });
  } catch (error) {
    console.error('Error fetching created quizzes:', error);
    return res.status(500).json({ 
      success: false,
      message: 'Error fetching created quizzes', 
      error: error.message 
    });
  }
};


exports.getMyAttemptedQuizzes = async (req, res) => {
  try {
    const user = req.user;
  
    if (!user) {
      return res.status(404).json({ message: 'User not found' });
    }

    // Sort quizzesTaken by submissionDate in descending order and take the first 4
    const attemptedQuizzes = user.quizzesTaken
      .sort((a, b) => b.submissionDate - a.submissionDate)
      .slice(0, 4);
    return res.status(200).json({ 
      success: true,
      quizzes: attemptedQuizzes 
    });

   
  } catch (error) {
    console.error('Error fetching attempted quizzes:', error);
    return res.status(500).json({ 
      success: false,
      message: 'Error fetching attempted quizzes', 
      error: error.message 
    });
  }
};

exports.submitQuizResult = async (req, res) => {
  const {
    quizId,
    userScore,
    totalScore,
    correctAnswers,
    wrongAnswers,
    learnLaterQuestions,
    timeTaken,
    difficulty,
    category
  } = req.body.quizResult;
  const user = req.user;
  try {
    const existingQuiz = user.quizzesTaken.find(
    (quiz) => quiz.quizId.toString() === quizId.toString() && quiz.difficulty === difficulty
    );

    if (existingQuiz) {
      // Adjust the user's total score (remove old score, add new one)
      user.totalScore -= existingQuiz.userScore;
      user.totalScore += userScore;

      // Update the existing quiz result
      existingQuiz.userScore = userScore;
      existingQuiz.maxQuizScore = totalScore;
      existingQuiz.submissionDate = new Date();
      existingQuiz.correctAnswers = correctAnswers;
      existingQuiz.wrongAnswers = wrongAnswers;
      existingQuiz.learnLater = learnLaterQuestions || [];
      existingQuiz.timeTaken = timeTaken;
    } else {
      // New quiz submission
      const newQuizResult = {
        quizId,
        userScore,
        maxQuizScore: totalScore,
        submissionDate: new Date(),
        correctAnswers,
        wrongAnswers,
        learnLater: learnLaterQuestions || [],
        timeTaken,
        difficulty:difficulty,
        category
      };
      user.quizzesTaken.push(newQuizResult);
      user.totalScore += userScore;
    }

    await user.save();
    res.status(200).json({ message: 'Quiz results submitted successfully' });

  } catch (error) {
    console.log(error);
    res.status(500).json({ message: 'Error submitting quiz results', error });
  }
};





exports.createQuiz = async (req, res) => {
  try {
    const { category, description, questions, } = req.body;

    if (!questions) {
      return res.status(400).json({ error: 'Questions are required.' });
    }

    // Initialize an object to hold question IDs by level
    const questionIds = {
      easy: [],
      medium: [],
      hard: [],
    };

    // Save each question and push its ID to the correct level
    for (const q of questions) {
      const newQuestion = new Question({
        ...q,
        level: q.level, // assuming level is in each question object
        createdBy: req.user._id,
      });
      const savedQuestion = await newQuestion.save();
      questionIds[q.level].push(savedQuestion._id);
    }

    // Create the quiz
    const newQuiz = new QuizSet({
      category,
      description,
      createdBy: req.user._id,
      questions: questionIds,
    });

    const savedQuiz = await newQuiz.save();

    res.status(201).json({
      message: 'Quiz created successfully',
      quiz: savedQuiz
    });
  } catch (error) {
    console.error('Error creating quiz:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
};

exports.updateQuiz = async (req, res) => {
  try {
    const quizId = req.params.id;
    const { description, questions } = req.body;
    const quiz = await QuizSet.findById(quizId);
    if (!quiz) {
      return res.status(404).json({ error: 'Quiz not found' });
    }

    // Check if the quiz belongs to the logged-in user
    if (quiz.createdBy.toString() !== req.user._id.toString()) {
      return res.status(403).json({ error: 'Unauthorized: You do not own this quiz' });
    }

    // Update fields
    if (description) quiz.description = description;
    if (questions) {
      const questionIds = {
        easy: [],
        medium: [],
        hard: [],
      };

      for (const q of questions) {
        const newQuestion = new Question({
          ...q,
          level: q.level,
          createdBy: req.user._id,
        });
        const savedQuestion = await newQuestion.save();
        questionIds[q.level].push(savedQuestion._id);
      }

      quiz.questions = questionIds;
    }

    const updatedQuiz = await quiz.save();

    res.status(200).json({
      message: 'Quiz updated successfully',
      quiz: updatedQuiz
    });
  } catch (error) {
    console.error('Error updating quiz:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
};


exports.quizOfTheDay= async (req, res) => {
  try {
    const today = new Date().toISOString().split('T')[0];

    if (cachedQuiz && lastQuizDate === today) {
      return res.json({ quiz: cachedQuiz });
    }

    const question = await generateQuizOfTheDay();
   if(!question)
    res.status(500).json({ error: "Failed to generate quiz question." });
    cachedQuiz = question;
    lastQuizDate = today;
    res.status(200).json({ quiz:question });
  } catch (error) {
    console.error("Error generating quiz:", error);
    res.status(500).json({ error: "Failed to generate quiz question." });
  }
};

exports.getLeaderboard = async (req, res) => {
  try {
    const {id:userId} = req.params; 
    console.log("Fetching leaderboard for userId:",userId );
    const allUsers = await User.find({}, { _id: 1 })
      .sort({ totalScore: -1 });// sorted based on totalscore

    // Step 2: Create a map of userId to rank
    const userRankMap = new Map();  // necessary to store userId and their rank
    allUsers.forEach((user, index) => {
      userRankMap.set(user._id.toString(), index + 1);
    });

    // Step 3: Fetch top 20 users with their info
    const leaderboard = await User.find({}, {
      username: 1,
      totalScore: 1,
      quizzesTaken: 1,
      avatar: 1,
      achievements: 1
    })
      .sort({ totalScore: -1 })
      .limit(20);

    const formattedLeaderboard = leaderboard.map((user, index) => ({
      rank: index + 1,
      username: user.username,
      totalScore: user.totalScore,
      quizzesTaken: user.quizzesTaken.length,
      avatar: user.avatar,
      achievements: user.achievements.length
    }));

    // Step 4: Get specific user's rank if userId is present
    let userRank = null;
    if (userId && userRankMap.has(userId)) {
      const targetUser = await User.findById(userId, {
        username: 1,
        totalScore: 1,
        quizzesTaken: 1,
        avatar: 1,
        achievements: 1
      });

      userRank = {
        rank: userRankMap.get(userId),
        username: targetUser.username,
        totalScore: targetUser.totalScore,
        quizzesTaken: targetUser.quizzesTaken.length,
        avatar: targetUser.avatar,
        achievements: targetUser.achievements.length
      };
    }

    res.status(200).json({
      leaderboard: formattedLeaderboard,
      userRank: userRank // will be null if no userId or user not found
    });
  } catch (error) {
    console.error('Error fetching leaderboard:', error);
    res.status(500).json({
      success: false,
      message: 'Error fetching leaderboard',
      error: error.message
    });
  }
};

exports.getUserSavedQuizzes= async (req, res) => {
  try {
    const user = await User.findById(req.user.id)
      .populate({
        path: 'savedQuizzes',
        populate: {
          path: 'createdBy',
          select: 'username'
        }
      });

    if (!user) {
      return res.status(404).json({ message: 'User not found' });
    }

    // Transform the data to match your frontend format
    const savedQuizzes = user.savedQuizzes.map(quiz => {
      // Find user's best score for this quiz
      const userQuizAttempts = user.quizzesTaken.filter(
        attempt => attempt.quizId.toString() === quiz._id.toString()
      );
      
      const bestScore = userQuizAttempts.length > 0 
        ? Math.max(...userQuizAttempts.map(attempt => 
            Math.round((attempt.userScore / attempt.maxQuizScore) * 100)
          ))
        : 0;

      // Find last played date
      const lastAttempt = userQuizAttempts.length > 0 
        ? userQuizAttempts.sort((a, b) => new Date(b.submissionDate) - new Date(a.submissionDate))[0]
        : null;

      const lastPlayed = lastAttempt 
        ? getTimeAgo(lastAttempt.submissionDate)
        : 'Never played';

      return {
        id: quiz._id,
        title: quiz.title,
        category: quiz.category,
        questions: quiz.questionCount || quiz.questions.length,
        timeEstimate: quiz.timeEstimate,
        difficulty: quiz.difficulty,
        lastPlayed,
        bestScore,
        favorite: true // All saved quizzes are considered favorites
      };
    });

    res.json({
      success: true,
      savedQuizzes
    });

  } catch (error) {
    console.error('Error fetching saved quizzes:', error);
    res.status(500).json({ 
      success: false, 
      message: 'Server error while fetching saved quizzes' 
    });
  }
}

exports.saveUnsaveQuiz= async (req, res) => {
  try {
    const { quizId } = req.params;
    const userId = req.user.id;

    // Verify quiz exists
    const quiz = await Quiz.findById(quizId);
    if (!quiz) {
      return res.status(404).json({ 
        success: false, 
        message: 'Quiz not found' 
      });
    }

    const user = await User.findById(userId);
    if (!user) {
      return res.status(404).json({ 
        success: false, 
        message: 'User not found' 
      });
    }

    const isAlreadySaved = user.savedQuizzes.includes(quizId);

    if (isAlreadySaved) {
      // Remove from saved quizzes
      user.savedQuizzes = user.savedQuizzes.filter(
        id => id.toString() !== quizId.toString()
      );
      await user.save();

      res.json({
        success: true,
        message: 'Quiz removed from saved quizzes',
        isSaved: false
      });
    } else {
      // Add to saved quizzes
      user.savedQuizzes.push(quizId);
      await user.save();

      res.json({
        success: true,
        message: 'Quiz saved successfully',
        isSaved: true
      });
    }

  } catch (error) {
    console.error('Error saving/unsaving quiz:', error);
    res.status(500).json({ 
      success: false, 
      message: 'Server error while saving quiz' 
    });
  }
}
